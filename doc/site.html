<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Röntgen Icon Set</title>
    <style>
        :root {
            --bg-color: #FFFFFF;
            --text-color: #000000;
            --preview-width: 512px;
            --info-width: 300px;
            --header-height: 60px;
            font-family: system-ui, -apple-system, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.5;
        }

        .header {
            height: var(--header-height);
            border-bottom: 1px solid #000000;
            display: flex;
            align-items: center;
            padding: 0 2rem;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: var(--bg-color);
            z-index: 100;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .main {
            display: flex;
            margin-top: var(--header-height);
            height: calc(100vh - var(--header-height));
        }

        .content {
            flex: 1;
            display: flex;
            overflow: hidden;
            min-width: calc(var(--preview-width) + var(--info-width));
        }

        .icon-grid-section {
            min-width: 300px;
            width: 30%;
            max-width: 600px;
            border-right: 1px solid #000000;
            overflow-y: auto;
            background: #FFFFFF;
            flex-shrink: 1;
        }

        .icon-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            border: 1px solid #000000;
            border-right: none;
            border-bottom: none;
        }

        .icon-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            border-right: 1px solid #000000;
            border-bottom: 1px solid #000000;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .icon-item:hover {
            background-color: #F3F4F6;
        }

        .icon-item.selected {
            background-color: #F3F4F6;
        }

        .icon-item svg {
            width: 24px;
            height: 24px;
            margin-bottom: 0.5rem;
        }

        .icon-item span {
            font-size: 0.75rem;
            text-align: center;
            word-break: break-word;
            color: #000000;
        }

        .icon-preview-section {
            width: var(--preview-width);
            min-width: var(--preview-width);
            max-width: var(--preview-width);
            border-right: 1px solid #000000;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #FFFFFF;
            flex: 0 0 var(--preview-width);
        }

        .icon-info-section {
            width: var(--info-width);
            min-width: var(--info-width);
            max-width: var(--info-width);
            padding: 2rem;
            overflow-y: auto;
            background: #FFFFFF;
            flex: 0 0 var(--info-width);
        }

        .icon-preview {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .icon-preview svg {
            width: 400px;
            height: 400px;
        }

        .icon-info-panel {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .icon-controls {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .icon-controls button {
            padding: 0.5rem 1rem;
            border: 1px solid #000000;
            background: #FFFFFF;
            color: #000000;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background-color 0.2s;
        }

        .icon-controls button:hover {
            background: #F3F4F6;
        }

        .icon-controls button.active {
            background: #F3F4F6;
        }

        .icon-controls .button-group {
            display: flex;
            gap: 0.5rem;
        }

        .size-control {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .size-control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .size-control-header label {
            font-size: 0.875rem;
            color: #000000;
        }

        .size-value {
            font-family: ui-monospace, monospace;
            font-size: 0.875rem;
            color: #000000;
            min-width: 4em;
            text-align: right;
        }

        /* Custom slider styles */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 1px;
            background: #000000;
            outline: none;
            margin: 0.5rem 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #FFFFFF;
            border: 1px solid #000000;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #F3F4F6;
        }

        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #FFFFFF;
            border: 1px solid #000000;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #F3F4F6;
        }

        input[type="range"]::-moz-range-track {
            height: 1px;
            background: #000000;
        }

        input[type="range"]:focus {
            outline: none;
        }

        .icon-metadata {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .icon-metadata h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0;
        }

        .icon-metadata .identifier {
            font-family: ui-monospace, monospace;
            font-size: 0.875rem;
        }

        .icon-metadata .description {
            font-size: 1rem;
            line-height: 1.5;
        }

        .icon-metadata .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .icon-metadata .tag {
            background: #F3F4F6;
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.875rem;
            color: #333333;
        }

        /* Add styles for control points */
        .control-point {
            fill: #000000;
            stroke-width: 0.1;
            r: 0.08;
            cursor: move;
        }

        .curve-point {
            fill: #000000;
            stroke-width: 0.1;
            r: 0.08;
            cursor: move;
        }

        .control-line {
            stroke: #000000;
            stroke-width: 0.02;
            opacity: 0.3;
        }

        .curve-line {
            stroke: #000000;
            stroke-width: 0.04;
        }

        @media (max-width: 1200px) {
            .main {
                flex-direction: column;
            }

            .content {
                flex-direction: column;
                height: calc(100vh - var(--header-height));
                min-width: 100%;
            }

            .icon-grid-section {
                width: 100%;
                min-width: 100%;
                max-width: 100%;
                height: 200px;
                border-right: none;
                border-bottom: 1px solid #000000;
            }

            .icon-preview-section {
                width: 100%;
                min-width: 100%;
                max-width: 100%;
                height: 50%;
                border-right: none;
                border-bottom: 1px solid #000000;
                flex: 0 0 50%;
            }

            .icon-info-section {
                width: 100%;
                min-width: 100%;
                max-width: 100%;
                height: 50%;
                flex: 0 0 50%;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>Röntgen Icon Set</h1>
    </header>

    <main class="main">
        <div class="content">
            <div class="icon-grid-section">
                <div class="icon-list" id="iconList">
                    <div class="icon-item" data-name="camp">
                        <svg viewBox="0 0 16 16">
                            <path d='M 6.4863,1.9941 C 6.1295,2.0021 5.896,2.3711 6.041,2.6973 C 6.2956,3.2913 6.6013,3.8975 6.9277,4.5059 C 5.341,7.3151 3.0844,10.2086 1.1465,12.1465 C 0.7934,12.4868 1.0903,13.0791 1.5742,13.0 L 6.0,13.0 L 6.0,11.5 C 6.0,10.6716 6.6716,10.0 7.5,10.0 C 8.3284,10.0 9.0,10.6716 9.0,11.5 L 9.0,13.0 L 13.4297,13.0 C 13.9114,13.0741 14.2037,12.4855 13.8535,12.1465 C 11.9156,10.2086 9.659,7.3151 8.0723,4.5059 C 8.3987,3.8975 8.7044,3.2913 8.959,2.6973 C 9.1067,2.365 8.8616,1.9912 8.4981,1.9941 C 8.2976,1.9961 8.1178,2.1176 8.041,2.3027 C 7.8805,2.6772 7.6946,3.0616 7.5,3.4473 C 7.3054,3.0616 7.1195,2.6772 6.959,2.3027 C 6.8801,2.1123 6.6924,1.9898 6.4863,1.9941' fill="currentColor"/>
                        </svg>
                        <span>camp</span>
                    </div>
                    <div class="icon-item" data-name="binoculars">
                        <svg viewBox="0 0 16 16">
                            <path d='M 5.5,3.0 A 1.5,1.5 0.0 0,0 4.1426,3.8652 L 1.4375,8.4375 L 1.4475,8.4315 A 3.0,3.0 0.0 0,0 1.0,10.0001 A 3.0,3.0 0.0 0,0 4.0,13.0001 A 3.0,3.0 0.0 0,0 7.0,10.0001 A 0.5,0.5 0.0 0,1 7.5,9.5001 A 0.5,0.5 0.0 0,1 8.0,10.0001 A 3.0,3.0 0.0 0,0 11.0,13.0001 A 3.0,3.0 0.0 0,0 14.0,10.0001 A 3.0,3.0 0.0 0,0 13.5567,8.4337 L 13.5627,8.4377 L 10.8576,3.8654 A 1.5,1.5 0.0 0,0 9.5,3.0001 A 1.5,1.5 0.0 0,0 8.0,4.5001 A 0.5,0.5 0.0 0,1 7.5,5.0001 A 0.5,0.5 0.0 0,1 7.0,4.5001 A 1.5,1.5 0.0 0,0 5.5,3.0001 L 5.5,3.0 M 4.0,8.0 A 2.0,2.0 0.0 0,1 6.0,10.0 A 2.0,2.0 0.0 0,1 4.0,12.0 A 2.0,2.0 0.0 0,1 2.0,10.0 A 2.0,2.0 0.0 0,1 4.0,8.0 M 11.0,8.0 A 2.0,2.0 0.0 0,1 13.0,10.0 A 2.0,2.0 0.0 0,1 11.0,12.0 A 2.0,2.0 0.0 0,1 9.0,10.0 A 2.0,2.0 0.0 0,1 11.0,8.0' fill="currentColor"/>
                        </svg>
                        <span>binoculars</span>
                    </div>
                    <div class="icon-item" data-name="car">
                        <svg viewBox="0 0 16 16">
                            <path d='M 9.0,4.0 C 9.3151,3.9999 9.6118,4.1482 9.8008,4.4004 L 11.0703,6.0938 L 13.1953,6.5195 C 13.663,6.6127 13.9998,7.0231 14.0,7.5 L 14.0,9.0 L 14.0,9.002 C 13.9993,10.1094 13.1076,11.0 12.0,11.0 C 11.0648,11.0 10.2834,10.3645 10.0625,9.5 L 5.9375,9.5 C 5.7166,10.3645 4.9352,11.0 4.0,11.0 C 2.8924,11.0 2.0007,10.1094 2.0,9.002 L 2.0,9.0 L 2.0,7.5 L 2.0,7.0 C 1.9999,6.9184 2.01,6.837 2.0293,6.7578 L 2.5293,4.7578 C 2.6405,4.3123 3.0408,3.9998 3.5,4.0 L 9.0,4.0 M 12.0,8.0 C 11.446,8.0 11.0,8.446 11.0,9.0 C 11.0,9.554 11.446,10.0 12.0,10.0 C 12.554,10.0 13.0,9.554 13.0,9.0 C 13.0,8.446 12.554,8.0 12.0,8.0 M 4.0,8.0 C 3.446,8.0 3.0,8.446 3.0,9.0 C 3.0,9.554 3.446,10.0 4.0,10.0 C 4.554,10.0 5.0,9.554 5.0,9.0 C 5.0,8.446 4.554,8.0 4.0,8.0' fill="currentColor"/>
                        </svg>
                        <span>car</span>
                    </div>
                    <div class="icon-item" data-name="crane">
                        <svg viewBox="0 0 16 16">
                            <path d='M 2.5,2.0 C 2.2239,2.0 2.0,2.2239 2.0,2.5 L 2.0,3.5 C 2.0,3.7761 2.2239,4.0 2.5,4.0 L 4.0,4.0 L 4.0,7.5 L 4.0,10.5 L 4.0,14.5 C 4.001,14.507 4.002,14.5131 4.004,14.5195 C 4.005,14.5749 4.0159,14.6297 4.0352,14.6816 C 4.0392,14.6896 4.0432,14.6973 4.0469,14.705 C 4.0709,14.7601 4.1046,14.8103 4.1465,14.8534 C 4.1896,14.8953 4.2399,14.929 4.2949,14.953 C 4.3029,14.957 4.3104,14.961 4.3183,14.9647 C 4.3702,14.984 4.4251,14.9946 4.4805,14.9959 C 4.4864,14.9969 4.4934,14.9989 4.5,15.0 C 4.507,14.999 4.5131,14.998 4.5195,14.9959 C 4.5749,14.995 4.6296,14.984 4.6816,14.9647 C 4.6896,14.9607 4.6973,14.9568 4.705,14.953 C 4.7601,14.929 4.8103,14.8953 4.8534,14.8534 L 6.0,13.707 L 6.0,14.5 C 6.0,14.7761 6.2239,15.0 6.5,15.0 C 6.7761,15.0 7.0,14.7761 7.0,14.5 L 7.0,12.5215 C 7.0006,12.5072 7.0006,12.4929 7.0,12.4785 L 7.0,11.5214 C 7.0006,11.5071 7.0006,11.4928 7.0,11.4784 L 7.0,10.5 L 7.0,7.5 L 7.0,6.5215 C 7.0006,6.5072 7.0006,6.4929 7.0,6.4785 L 7.0,5.5214 C 7.0006,5.5071 7.0006,5.4928 7.0,5.4784 L 7.0,4.0 L 8.5,4.0 L 11.0,4.0 L 11.0,8.5 C 11.0003,8.7262 11.1525,8.9241 11.3711,8.9824 C 11.4131,8.9939 11.4565,8.9998 11.5,9.0 C 11.7037,9.0 11.885,9.1205 11.9629,9.3086 C 12.0408,9.4968 11.9975,9.7095 11.8535,9.8535 C 11.7095,9.9975 11.4968,10.0409 11.3086,9.9629 C 11.1204,9.885 11.0,9.7037 11.0,9.5 C 11.0,9.2239 10.7761,9.0 10.5,9.0 C 10.2239,9.0 10.0,9.2239 10.0,9.5 C 10.0,10.1053 10.3666,10.6551 10.9258,10.8867 C 11.485,11.1183 12.1326,10.9885 12.5605,10.5606 C 12.9885,10.1326 13.1183,9.485 12.8867,8.9258 C 12.7215,8.5269 12.3936,8.2276 12.0,8.0879 L 12.0,4.0 L 13.5,4.0 C 13.7761,4.0 14.0,3.7761 14.0,3.5 C 14.0,3.2239 13.7761,3.0 13.5,3.0 L 8.707,3.0 L 7.8535,2.1465 C 7.7598,2.0527 7.6326,2.0 7.5,2.0 L 2.5,2.0 M 5.0,4.707 L 6.0,5.707 L 6.0,6.293 L 5.0,7.293 L 5.0,4.707 M 6.0,7.707 L 6.0,10.293 L 5.0,9.293 L 5.0,8.707 L 6.0,7.707 M 5.0,10.707 L 6.0,11.707 L 6.0,12.293 L 5.0,13.293 L 5.0,10.707' fill="currentColor"/>
                        </svg>
                        <span>crane</span>
                    </div>
                </div>
            </div>
            <div class="icon-preview-section">
                <div class="icon-preview">
                    <svg id="previewSvg" viewBox="0 0 16 16"></svg>
                </div>
            </div>
            <div class="icon-info-section">
                <div class="icon-info-panel">
                    <div class="icon-controls">
                        <div class="button-group">
                            <button id="toggleControlPoints">Show control points</button>
                            <button id="downloadIcon">Download SVG</button>
                        </div>
                        <div class="size-control">
                            <div class="size-control-header">
                                <label>Icon size</label>
                                <span class="size-value">512px</span>
                            </div>
                            <input type="range" id="sizeSlider" min="16" max="512" value="512" step="1">
                        </div>
                    </div>
                    <div class="icon-metadata">
                        <h2 id="iconName">Select an icon</h2>
                        <div class="identifier" id="iconIdentifier"></div>
                        <div class="description" id="iconDescription"></div>
                        <div class="tags" id="iconTags"></div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // State management
        let selectedIcon = null;
        let showControlPoints = false;
        let iconSize = 512;

        // Icon data
        const icons = {
            camp: {
                name: "Camp",
                identifier: "camp",
                description: "A simple tent icon representing camping or outdoor activities.",
                tags: ["outdoor", "nature", "shelter"],
                path: "M 6.4863,1.9941 C 6.1295,2.0021 5.896,2.3711 6.041,2.6973 C 6.2956,3.2913 6.6013,3.8975 6.9277,4.5059 C 5.341,7.3151 3.0844,10.2086 1.1465,12.1465 C 0.7934,12.4868 1.0903,13.0791 1.5742,13.0 L 6.0,13.0 L 6.0,11.5 C 6.0,10.6716 6.6716,10.0 7.5,10.0 C 8.3284,10.0 9.0,10.6716 9.0,11.5 L 9.0,13.0 L 13.4297,13.0 C 13.9114,13.0741 14.2037,12.4855 13.8535,12.1465 C 11.9156,10.2086 9.659,7.3151 8.0723,4.5059 C 8.3987,3.8975 8.7044,3.2913 8.959,2.6973 C 9.1067,2.365 8.8616,1.9912 8.4981,1.9941 C 8.2976,1.9961 8.1178,2.1176 8.041,2.3027 C 7.8805,2.6772 7.6946,3.0616 7.5,3.4473 C 7.3054,3.0616 7.1195,2.6772 6.959,2.3027 C 6.8801,2.1123 6.6924,1.9898 6.4863,1.9941"
            },
            binoculars: {
                name: "Binoculars",
                identifier: "binoculars",
                description: "A pair of binoculars icon, useful for viewing or observation interfaces.",
                tags: ["view", "observe", "magnify"],
                path: "M 5.5,3.0 A 1.5,1.5 0.0 0,0 4.1426,3.8652 L 1.4375,8.4375 L 1.4475,8.4315 A 3.0,3.0 0.0 0,0 1.0,10.0001 A 3.0,3.0 0.0 0,0 4.0,13.0001 A 3.0,3.0 0.0 0,0 7.0,10.0001 A 0.5,0.5 0.0 0,1 7.5,9.5001 A 0.5,0.5 0.0 0,1 8.0,10.0001 A 3.0,3.0 0.0 0,0 11.0,13.0001 A 3.0,3.0 0.0 0,0 14.0,10.0001 A 3.0,3.0 0.0 0,0 13.5567,8.4337 L 13.5627,8.4377 L 10.8576,3.8654 A 1.5,1.5 0.0 0,0 9.5,3.0001 A 1.5,1.5 0.0 0,0 8.0,4.5001 A 0.5,0.5 0.0 0,1 7.5,5.0001 A 0.5,0.5 0.0 0,1 7.0,4.5001 A 1.5,1.5 0.0 0,0 5.5,3.0001 L 5.5,3.0 M 4.0,8.0 A 2.0,2.0 0.0 0,1 6.0,10.0 A 2.0,2.0 0.0 0,1 4.0,12.0 A 2.0,2.0 0.0 0,1 2.0,10.0 A 2.0,2.0 0.0 0,1 4.0,8.0 M 11.0,8.0 A 2.0,2.0 0.0 0,1 13.0,10.0 A 2.0,2.0 0.0 0,1 11.0,12.0 A 2.0,2.0 0.0 0,1 9.0,10.0 A 2.0,2.0 0.0 0,1 11.0,8.0"
            },
            car: {
                name: "Car",
                identifier: "car",
                description: "A simple car icon, perfect for transportation or vehicle-related interfaces.",
                tags: ["transport", "vehicle", "travel"],
                path: "M 9.0,4.0 C 9.3151,3.9999 9.6118,4.1482 9.8008,4.4004 L 11.0703,6.0938 L 13.1953,6.5195 C 13.663,6.6127 13.9998,7.0231 14.0,7.5 L 14.0,9.0 L 14.0,9.002 C 13.9993,10.1094 13.1076,11.0 12.0,11.0 C 11.0648,11.0 10.2834,10.3645 10.0625,9.5 L 5.9375,9.5 C 5.7166,10.3645 4.9352,11.0 4.0,11.0 C 2.8924,11.0 2.0007,10.1094 2.0,9.002 L 2.0,9.0 L 2.0,7.5 L 2.0,7.0 C 1.9999,6.9184 2.01,6.837 2.0293,6.7578 L 2.5293,4.7578 C 2.6405,4.3123 3.0408,3.9998 3.5,4.0 L 9.0,4.0 M 12.0,8.0 C 11.446,8.0 11.0,8.446 11.0,9.0 C 11.0,9.554 11.446,10.0 12.0,10.0 C 12.554,10.0 13.0,9.554 13.0,9.0 C 13.0,8.446 12.554,8.0 12.0,8.0 M 4.0,8.0 C 3.446,8.0 3.0,8.446 3.0,9.0 C 3.0,9.554 3.446,10.0 4.0,10.0 C 4.554,10.0 5.0,9.554 5.0,9.0 C 5.0,8.446 4.554,8.0 4.0,8.0"
            },
            crane: {
                name: "Crane",
                identifier: "crane",
                description: "A construction crane icon, ideal for building or construction-related interfaces.",
                tags: ["construction", "building", "industrial"],
                path: "M 2.5,2.0 C 2.2239,2.0 2.0,2.2239 2.0,2.5 L 2.0,3.5 C 2.0,3.7761 2.2239,4.0 2.5,4.0 L 4.0,4.0 L 4.0,7.5 L 4.0,10.5 L 4.0,14.5 C 4.001,14.507 4.002,14.5131 4.004,14.5195 C 4.005,14.5749 4.0159,14.6297 4.0352,14.6816 C 4.0392,14.6896 4.0432,14.6973 4.0469,14.705 C 4.0709,14.7601 4.1046,14.8103 4.1465,14.8534 C 4.1896,14.8953 4.2399,14.929 4.2949,14.953 C 4.3029,14.957 4.3104,14.961 4.3183,14.9647 C 4.3702,14.984 4.4251,14.9946 4.4805,14.9959 C 4.4864,14.9969 4.4934,14.9989 4.5,15.0 C 4.507,14.999 4.5131,14.998 4.5195,14.9959 C 4.5749,14.995 4.6296,14.984 4.6816,14.9647 C 4.6896,14.9607 4.6973,14.9568 4.705,14.953 C 4.7601,14.929 4.8103,14.8953 4.8534,14.8534 L 6.0,13.707 L 6.0,14.5 C 6.0,14.7761 6.2239,15.0 6.5,15.0 C 6.7761,15.0 7.0,14.7761 7.0,14.5 L 7.0,12.5215 C 7.0006,12.5072 7.0006,12.4929 7.0,12.4785 L 7.0,11.5214 C 7.0006,11.5071 7.0006,11.4928 7.0,11.4784 L 7.0,10.5 L 7.0,7.5 L 7.0,6.5215 C 7.0006,6.5072 7.0006,6.4929 7.0,6.4785 L 7.0,5.5214 C 7.0006,5.5071 7.0006,5.4928 7.0,5.4784 L 7.0,4.0 L 8.5,4.0 L 11.0,4.0 L 11.0,8.5 C 11.0003,8.7262 11.1525,8.9241 11.3711,8.9824 C 11.4131,8.9939 11.4565,8.9998 11.5,9.0 C 11.7037,9.0 11.885,9.1205 11.9629,9.3086 C 12.0408,9.4968 11.9975,9.7095 11.8535,9.8535 C 11.7095,9.9975 11.4968,10.0409 11.3086,9.9629 C 11.1204,9.885 11.0,9.7037 11.0,9.5 C 11.0,9.2239 10.7761,9.0 10.5,9.0 C 10.2239,9.0 10.0,9.2239 10.0,9.5 C 10.0,10.1053 10.3666,10.6551 10.9258,10.8867 C 11.485,11.1183 12.1326,10.9885 12.5605,10.5606 C 12.9885,10.1326 13.1183,9.485 12.8867,8.9258 C 12.7215,8.5269 12.3936,8.2276 12.0,8.0879 L 12.0,4.0 L 13.5,4.0 C 13.7761,4.0 14.0,3.7761 14.0,3.5 C 14.0,3.2239 13.7761,3.0 13.5,3.0 L 8.707,3.0 L 7.8535,2.1465 C 7.7598,2.0527 7.6326,2.0 7.5,2.0 L 2.5,2.0 M 5.0,4.707 L 6.0,5.707 L 6.0,6.293 L 5.0,7.293 L 5.0,4.707 M 6.0,7.707 L 6.0,10.293 L 5.0,9.293 L 5.0,8.707 L 6.0,7.707 M 5.0,10.707 L 6.0,11.707 L 6.0,12.293 L 5.0,13.293 L 5.0,10.707"
            }
        };

        // Function to extract control points
        function extractControlPoints(pathData) {
            const points = [];
            const commands = pathData.match(/[MLHVCSQTAZmlhvcsqtaz]|[+-]?\d*\.?\d+/g) || [];

            let x = 0, y = 0;
            let prevX = 0, prevY = 0;
            let controlX = 0, controlY = 0;

            for (let i = 0; i < commands.length; i++) {
                const cmd = commands[i];

                if (cmd.match(/[MLHVCSQTAZmlhvcsqtaz]/)) {
                    const command = cmd.toUpperCase();

                    // Handle different commands
                    switch (command) {
                        case "M":
                            x = parseFloat(commands[++i]);
                            y = parseFloat(commands[++i]);
                            points.push({ x, y, type: "move" });
                            break;
                        case "L":
                            x = parseFloat(commands[++i]);
                            y = parseFloat(commands[++i]);
                            points.push({ x, y, type: "line" });
                            break;
                        case "C":
                            const x1 = parseFloat(commands[++i]);
                            const y1 = parseFloat(commands[++i]);
                            const x2 = parseFloat(commands[++i]);
                            const y2 = parseFloat(commands[++i]);
                            x = parseFloat(commands[++i]);
                            y = parseFloat(commands[++i]);
                            points.push(
                                { x: x1, y: y1, type: "control", connectsTo: "start" },
                                { x: x2, y: y2, type: "control", connectsTo: "end" },
                                { x, y, type: "curve" }
                            );
                            break;
                        case "S":
                            const x2s = parseFloat(commands[++i]);
                            const y2s = parseFloat(commands[++i]);
                            x = parseFloat(commands[++i]);
                            y = parseFloat(commands[++i]);
                            // Calculate reflection of previous control point
                            const prevControlX = 2 * x - controlX;
                            const prevControlY = 2 * y - controlY;
                            points.push(
                                { x: prevControlX, y: prevControlY, type: "control", connectsTo: "start" },
                                { x: x2s, y: y2s, type: "control", connectsTo: "end" },
                                { x, y, type: "curve" }
                            );
                            break;
                        case "Q":
                            const qx1 = parseFloat(commands[++i]);
                            const qy1 = parseFloat(commands[++i]);
                            x = parseFloat(commands[++i]);
                            y = parseFloat(commands[++i]);
                            points.push(
                                { x: qx1, y: qy1, type: "control", connectsTo: "both" },
                                { x, y, type: "quadratic" }
                            );
                            break;
                        case "T":
                            x = parseFloat(commands[++i]);
                            y = parseFloat(commands[++i]);
                            // Calculate reflection of previous control point
                            const qPrevControlX = 2 * x - controlX;
                            const qPrevControlY = 2 * y - controlY;
                            points.push(
                                { x: qPrevControlX, y: qPrevControlY, type: "control", connectsTo: "both" },
                                { x, y, type: "quadratic" }
                            );
                            break;
                        case "Z":
                            points.push({ x, y, type: "close" });
                            break;
                        case "A":
                            const rx = parseFloat(commands[++i]);
                            const ry = parseFloat(commands[++i]);
                            const xAxisRotation = parseFloat(commands[++i]);
                            const largeArcFlag = parseFloat(commands[++i]);
                            const sweepFlag = parseFloat(commands[++i]);
                            x = parseFloat(commands[++i]);
                            y = parseFloat(commands[++i]);
                            
                            // For arcs, we'll only add the start and end points
                            const startX = prevX;
                            const startY = prevY;
                            
                            // Add the start point if it's not already added
                            if (points.length === 0 || points[points.length - 1].type !== "move") {
                                points.push({ x: startX, y: startY, type: "arc-start" });
                            }
                            
                            // Add the end point
                            points.push({ x, y, type: "arc-end" });
                            break;
                    }

                    prevX = x;
                    prevY = y;
                    if (command === "C" || command === "S" || command === "Q" || command === "T") {
                        controlX = x;
                        controlY = y;
                    }
                }
            }

            return points;
        }

        // Function to draw control points
        function drawControlPoints(points) {
            const layer = document.getElementById("controlPointsLayer");
            layer.innerHTML = "";
            
            if (!showControlPoints) return;

            // Draw all points first
            points.forEach(point => {
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                if (point.type === "control") {
                    circle.setAttribute("class", "control-point");
                } else if (point.type === "arc-start" || point.type === "arc-end") {
                    circle.setAttribute("class", "curve-point");
                } else {
                    circle.setAttribute("class", point.type === "control" ? "control-point" : "curve-point");
                }
                circle.setAttribute("cx", point.x);
                circle.setAttribute("cy", point.y);
                layer.appendChild(circle);
            });

            // Draw control lines for Bezier curves
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                if (point.type === "control") {
                    if (point.connectsTo === "both") {
                        // For quadratic curves, connect to both previous and next points
                        const prevPoint = points[i - 1];
                        const nextPoint = points[i + 1];
                        if (prevPoint && prevPoint.type !== "control") {
                            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                            line.setAttribute("class", "control-line");
                            line.setAttribute("x1", point.x);
                            line.setAttribute("y1", point.y);
                            line.setAttribute("x2", prevPoint.x);
                            line.setAttribute("y2", prevPoint.y);
                            layer.appendChild(line);
                        }
                        if (nextPoint && nextPoint.type !== "control") {
                            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                            line.setAttribute("class", "control-line");
                            line.setAttribute("x1", point.x);
                            line.setAttribute("y1", point.y);
                            line.setAttribute("x2", nextPoint.x);
                            line.setAttribute("y2", nextPoint.y);
                            layer.appendChild(line);
                        }
                    } else if (point.connectsTo === "arc-start" || point.connectsTo === "arc-end") {
                        // Skip control lines for arcs
                        continue;
                    } else {
                        // For cubic curves, connect to either start or end point
                        const targetIndex = point.connectsTo === "start" ? i - 1 : i + 1;
                        const targetPoint = points[targetIndex];
                        if (targetPoint && targetPoint.type !== "control") {
                            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                            line.setAttribute("class", "control-line");
                            line.setAttribute("x1", point.x);
                            line.setAttribute("y1", point.y);
                            line.setAttribute("x2", targetPoint.x);
                            line.setAttribute("y2", targetPoint.y);
                            layer.appendChild(line);
                        }
                    }
                }
            }
        }

        // Update icon style
        function updateIconStyle() {
            const svg = document.getElementById("previewSvg");
            if (!svg) return;

            // Update SVG size
            svg.style.width = `${iconSize}px`;
            svg.style.height = `${iconSize}px`;

            // Clear the SVG
            svg.innerHTML = "";

            // Add the path
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", selectedIcon.path);
            path.style.fill = "currentColor";
            path.style.stroke = "currentColor";
            path.style.strokeWidth = "0.05";
            
            if (showControlPoints) {
                path.style.fillOpacity = "0.05";
            } else {
                path.style.fillOpacity = "1";
            }
            
            svg.appendChild(path);

            // If showing control points, add them to the same SVG
            if (showControlPoints) {
                const points = extractControlPoints(selectedIcon.path);
                
                // Create a group for control elements to ensure they're drawn on top
                const controlGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                controlGroup.setAttribute("class", "control-elements");
                
                // Draw all points
                points.forEach(point => {
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    if (point.type === "control") {
                        circle.setAttribute("class", "control-point");
                    } else if (point.type === "arc-start" || point.type === "arc-end") {
                        circle.setAttribute("class", "curve-point");
                    } else {
                        circle.setAttribute("class", point.type === "control" ? "control-point" : "curve-point");
                    }
                    circle.setAttribute("cx", point.x);
                    circle.setAttribute("cy", point.y);
                    controlGroup.appendChild(circle);
                });

                // Draw control lines for Bezier curves
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    if (point.type === "control") {
                        if (point.connectsTo === "both") {
                            // For quadratic curves, connect to both previous and next points
                            const prevPoint = points[i - 1];
                            const nextPoint = points[i + 1];
                            if (prevPoint && prevPoint.type !== "control") {
                                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                                line.setAttribute("class", "control-line");
                                line.setAttribute("x1", point.x);
                                line.setAttribute("y1", point.y);
                                line.setAttribute("x2", prevPoint.x);
                                line.setAttribute("y2", prevPoint.y);
                                controlGroup.appendChild(line);
                            }
                            if (nextPoint && nextPoint.type !== "control") {
                                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                                line.setAttribute("class", "control-line");
                                line.setAttribute("x1", point.x);
                                line.setAttribute("y1", point.y);
                                line.setAttribute("x2", nextPoint.x);
                                line.setAttribute("y2", nextPoint.y);
                                controlGroup.appendChild(line);
                            }
                        } else if (point.connectsTo === "arc-start" || point.connectsTo === "arc-end") {
                            // Skip control lines for arcs
                            continue;
                        } else {
                            // For cubic curves, connect to either start or end point
                            const targetIndex = point.connectsTo === "start" ? i - 1 : i + 1;
                            const targetPoint = points[targetIndex];
                            if (targetPoint && targetPoint.type !== "control") {
                                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                                line.setAttribute("class", "control-line");
                                line.setAttribute("x1", point.x);
                                line.setAttribute("y1", point.y);
                                line.setAttribute("x2", targetPoint.x);
                                line.setAttribute("y2", targetPoint.y);
                                controlGroup.appendChild(line);
                            }
                        }
                    }
                }

                svg.appendChild(controlGroup);
            }
        }

        // Select and display icon
        function selectIcon(name) {
            selectedIcon = icons[name];
            if (!selectedIcon) return;

            // Update UI
            document.querySelectorAll(".icon-item").forEach((item) => {
                item.classList.toggle("selected", item.dataset.name === name);
            });

            // Update metadata
            document.getElementById("iconName").textContent = selectedIcon.name;
            document.getElementById("iconIdentifier").textContent = selectedIcon.identifier;
            document.getElementById("iconDescription").textContent = selectedIcon.description;
            
            // Update tags
            const tagsContainer = document.getElementById("iconTags");
            tagsContainer.innerHTML = "";
            selectedIcon.tags.forEach((tag) => {
                const tagElement = document.createElement("span");
                tagElement.className = "tag";
                tagElement.textContent = tag;
                tagsContainer.appendChild(tagElement);
            });

            updateIconStyle();
        }

        // Function to create downloadable SVG
        function createDownloadableSVG() {
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            svg.setAttribute("width", "16");
            svg.setAttribute("height", "16");
            svg.setAttribute("viewBox", "0 0 16 16");

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", selectedIcon.path);
            path.setAttribute("fill", "currentColor");
            svg.appendChild(path);

            return new XMLSerializer().serializeToString(svg);
        }

        // Function to download SVG
        function downloadSVG() {
            if (!selectedIcon) return;

            const svgContent = createDownloadableSVG();
            const blob = new Blob([svgContent], { type: "image/svg+xml" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = `${selectedIcon.identifier}.svg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Event listeners
        document.querySelectorAll(".icon-item").forEach((item) => {
            item.addEventListener("click", () => selectIcon(item.dataset.name));
        });

        document.getElementById("toggleControlPoints").addEventListener("click", () => {
            const button = document.getElementById("toggleControlPoints");
            showControlPoints = !showControlPoints;
            button.classList.toggle("active");
            button.textContent = showControlPoints ? "Hide control points" : "Show control points";
            updateIconStyle();
        });

        document.getElementById("downloadIcon").addEventListener("click", downloadSVG);

        const sizeSlider = document.getElementById("sizeSlider");

        sizeSlider.addEventListener("input", (e) => {
            iconSize = parseInt(e.target.value);
            document.querySelector(".size-value").textContent = `${iconSize}px`;
            updateIconStyle();
        });

        // Select first icon by default
        selectIcon("camp");
        // Set initial size value
        document.querySelector(".size-value").textContent = `${iconSize}px`;
    </script>
</body>
</html> 